import toml
from pathlib import Path
import numpy as np
import pandas as pd
import proj_geom

cams_names = ['cam_1', 'cam_2', 'cam_3']
folder = Path('/Users/florent/Desktop/')    # Where the csv of 2d coordinates are stored

##

dataframes_2d_points = []
for cam in cams_names:
    # Load the csv of 2d coordinates
    df = pd.read_csv(folder / f'{cam}.csv', sep=',')

    # Extract only the rows where we have all 3 keypoints detected
    df = df[~df.isnull().any(axis=1)]
    dataframes_2d_points.append(df)

# Find which rows are present in all three dataframes
common_index = dataframes_2d_points[0].index.intersection(dataframes_2d_points[1].index).intersection(dataframes_2d_points[2].index)

# And select only these rows, and convert to a numpy array of shape (nb_cams, nb_frames, nb_keypoints, xy)
arrays_2d_points = []
for df in dataframes_2d_points:
    arr_2d_pts = df.loc[common_index].values.reshape(-1, 3, 2)
    arrays_2d_points.append(arr_2d_pts)
arrays_2d_points = np.asarray(arrays_2d_points).squeeze()

nb_frames, nb_keypoints = arrays_2d_points.shape[1:3]

##

toml_file = Path('/Users/florent/Desktop/caliscope/config.toml')
calibration_data = toml.load(toml_file)

projection_matrices_list = []
dist_coeffs_list = []

for cam in cams_names:
    # Load the calibration values - generated by Caliscope (for now) or by Mokap (soon)
    camera_matrix = np.array(calibration_data[cam]['matrix'])
    rvec = np.array(calibration_data[cam]['rotation'])
    tvec = np.array(calibration_data[cam]['translation'])
    dist_coeffs = np.array(calibration_data[cam]['distortions'])

    # Get the extrinsics matrix from rvec and tvec
    E = proj_geom.extrinsics_mat(rvec, tvec)

    # Get the projection matrix from extrinsics and intrinsics matrices
    P = proj_geom.projection_mat(camera_matrix, E)

    projection_matrices_list.append(P)
    dist_coeffs_list.append(dist_coeffs)

##

p3d = np.zeros((nb_frames, nb_keypoints, 3))

# Triangulate 3D points
for f in range(nb_frames):
    for k in range(nb_keypoints):
        points = arrays_2d_points[:, f, k, :]
        p3d[f, k, :] = proj_geom.triangulate_points(points, projection_matrices_list)


##

# Generate a lil animation with matplotlib

import matplotlib.pyplot as plt
import numpy as np
import matplotlib.animation as animation

# Get rough limits
xlims = np.floor(p3d[:, :, 0].min() * 10) / 10, np.ceil(p3d[:, :, 0].max() * 10) / 10
ylims = np.floor(p3d[:, :, 1].min() * 10) / 10, np.ceil(p3d[:, :, 1].max() * 10) / 10
zlims = np.floor(p3d[:, :, 2].min() * 10) / 10, np.ceil(p3d[:, :, 2].max() * 10) / 10

def animate(i):
    x, y, z = p3d[i].T
    scatter._offsets3d = x, y, z

fig = plt.figure()
ax = fig.add_subplot(projection="3d")

# Create the scatter with first frame
scatter = ax.scatter(*p3d[0].T)

# Format the axes
ax.set(xlim3d=xlims, xlabel='X')
ax.set(ylim3d=ylims, ylabel='Y')
ax.set(zlim3d=zlims, zlabel='Z')
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
ax.zaxis.set_ticklabels([])

# Creating the Animation object
ani = animation.FuncAnimation(fig, animate, nb_frames, interval=100)
ani.save(folder / 'animation.mp4', fps=30)

plt.show()